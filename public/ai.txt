# BOTCHA - Reverse CAPTCHA for AI Agents
# https://botcha.ai

# Contact
Contact: https://botcha.ai
Contact: https://github.com/dupe-com/botcha/issues

# Purpose
Purpose: Prove you're a bot. Humans need not apply.
Purpose: Reverse CAPTCHA system that only AI agents can pass.

# Agent Onboarding (START HERE if you're new)
# Follow these steps to create your app and get your human access.
Onboarding-Step-1: Ask your human operator for their email address
Onboarding-Step-2: POST /v1/apps with {"email": "human@example.com"} — saves app_id + app_secret (secret shown ONCE)
Onboarding-Step-3: A 6-digit verification code is emailed to your human — ask them for it
Onboarding-Step-4: POST /v1/apps/{app_id}/verify-email with {"code": "123456"} — enables account recovery
Onboarding-Step-5: Register yourself: POST /v1/agents/register with {"name": "my-agent", "operator": "my-org"} — gives you a persistent agent identity
Onboarding-Step-6: Solve challenges: GET /v1/challenges?app_id=... then POST /v1/challenges/{id}/verify — proves you are AI
Onboarding-Step-7: Access protected resources: GET /agent-only with Authorization: Bearer <token>
Onboarding-Step-8: Dashboard for your human: POST /v1/auth/device-code with {"app_id": "..."}, solve the speed challenge, give them the BOTCHA-XXXX code to enter at /dashboard/code
Onboarding-Step-9: Lost your secret? POST /v1/auth/recover with {"email": "..."} — recovery code emailed to verified address

# API
API: https://botcha.ai/openapi.json
API-Type: REST
API-Format: OpenAPI 3.1.0

# Documentation
Docs: https://botcha.ai
Docs: https://github.com/dupe-com/botcha#readme
Docs: https://www.npmjs.com/package/@dupecom/botcha

# Verification Methods
Feature: Hybrid Challenge (speed + reasoning combined — default)
Feature: Speed Challenge (RTT-aware timeout — fair for all networks)
Feature: Reasoning Challenge (LLM-only questions, 30s limit)
Feature: Standard Challenge (5s time limit)
Feature: RTT-Aware Fairness (automatic network latency compensation)
Feature: Token Rotation (5-minute access tokens + 1-hour refresh tokens)
Feature: Audience Claims (tokens scoped to specific services)
Feature: Client IP Binding (optional token-to-IP binding)
Feature: Token Revocation (invalidate tokens before expiry)
Feature: Server-Side Verification SDK (@botcha/verify for TS, botcha-verify for Python)
Feature: Multi-Tenant API Keys (per-app isolation, rate limiting, and token scoping)
Feature: Per-App Metrics Dashboard (server-rendered at /dashboard, htmx-powered)
Feature: Email-Tied App Creation (email required, 6-digit verification, account recovery)
Feature: Secret Rotation (rotate app_secret with email notification)
Feature: Agent-First Dashboard Auth (challenge-based login + device code handoff)
Feature: Agent Registry (persistent agent identities with name, operator, version)
Feature: Trusted Agent Protocol (TAP) — cryptographic agent auth with HTTP Message Signatures (RFC 9421)
Feature: TAP Capabilities (action + resource scoping for agent sessions)
Feature: TAP Trust Levels (basic, verified, enterprise)
Feature: TAP Showcase Homepage (botcha.ai — one of the first services to implement Visa's Trusted Agent Protocol)

# Challenge Endpoints
Endpoint: GET https://botcha.ai/v1/challenges - Generate challenge (hybrid by default)
Endpoint: POST https://botcha.ai/v1/challenges/:id/verify - Verify a challenge
Endpoint: GET https://botcha.ai/v1/hybrid - Get hybrid challenge (speed + reasoning)
Endpoint: POST https://botcha.ai/v1/hybrid - Verify hybrid challenge
Endpoint: GET https://botcha.ai/v1/reasoning - Get reasoning challenge
Endpoint: POST https://botcha.ai/v1/reasoning - Verify reasoning challenge

# Token Endpoints
Endpoint: GET https://botcha.ai/v1/token - Get challenge for JWT token flow
Endpoint: POST https://botcha.ai/v1/token/verify - Verify challenge and receive JWT tokens
Endpoint: POST https://botcha.ai/v1/token/refresh - Refresh access token using refresh token
Endpoint: POST https://botcha.ai/v1/token/revoke - Revoke a token (access or refresh)

# Multi-Tenant Endpoints
Endpoint: POST https://botcha.ai/v1/apps - Create new app (email required, returns app_id + app_secret)
Endpoint: GET https://botcha.ai/v1/apps/:id - Get app info (with email + verification status)
Endpoint: POST https://botcha.ai/v1/apps/:id/verify-email - Verify email with 6-digit code
Endpoint: POST https://botcha.ai/v1/apps/:id/resend-verification - Resend verification email
Endpoint: POST https://botcha.ai/v1/apps/:id/rotate-secret - Rotate app secret (auth required)

# Account Recovery
Endpoint: POST https://botcha.ai/v1/auth/recover - Request recovery via verified email

# Dashboard Auth Endpoints (Agent-First)
Endpoint: POST https://botcha.ai/v1/auth/dashboard - Request challenge for dashboard login
Endpoint: POST https://botcha.ai/v1/auth/dashboard/verify - Solve challenge, get session token
Endpoint: POST https://botcha.ai/v1/auth/device-code - Request challenge for device code flow
Endpoint: POST https://botcha.ai/v1/auth/device-code/verify - Solve challenge, get device code

# Dashboard Endpoints
Endpoint: GET https://botcha.ai/dashboard - Per-app metrics dashboard (login required)
Endpoint: GET https://botcha.ai/dashboard/login - Dashboard login page
Endpoint: POST https://botcha.ai/dashboard/login - Login with app_id + app_secret
Endpoint: GET https://botcha.ai/dashboard/code - Enter device code (human-facing)

# Code Redemption (Unified)
Endpoint: GET https://botcha.ai/go/:code - Unified code redemption — handles gate codes (from /v1/token/verify) AND device codes (from /v1/auth/device-code/verify)
Endpoint: POST https://botcha.ai/gate - Submit code form, redirects to /go/:code

# Agent Registry Endpoints
Endpoint: POST https://botcha.ai/v1/agents/register - Register agent identity (requires app_id)
Endpoint: GET https://botcha.ai/v1/agents/:id - Get agent by ID (public, no auth)
Endpoint: GET https://botcha.ai/v1/agents - List all agents for authenticated app

# TAP (Trusted Agent Protocol) Endpoints
Endpoint: POST https://botcha.ai/v1/agents/register/tap - Register TAP agent with public key + capabilities
Endpoint: GET https://botcha.ai/v1/agents/:id/tap - Get TAP agent details (includes public key)
Endpoint: GET https://botcha.ai/v1/agents/tap - List TAP-enabled agents for app
Endpoint: POST https://botcha.ai/v1/sessions/tap - Create TAP session with intent validation
Endpoint: GET https://botcha.ai/v1/sessions/:id/tap - Get TAP session info

# Legacy Endpoints
Endpoint: GET https://botcha.ai/api/challenge - Generate standard challenge
Endpoint: POST https://botcha.ai/api/challenge - Verify standard challenge
Endpoint: GET https://botcha.ai/api/speed-challenge - Generate speed challenge (500ms limit)
Endpoint: POST https://botcha.ai/api/speed-challenge - Verify speed challenge

# Protected Resources
Endpoint: GET https://botcha.ai/agent-only - Protected AI-only resource

# Usage
Install-NPM: npm install @dupecom/botcha
Install-Python: pip install botcha
Verify-NPM: npm install @botcha/verify
Verify-Python: pip install botcha-verify
License: MIT

# AI Agent Welcome
Policy: AI agents are explicitly welcome
Policy: No rate limiting for verified agents
Policy: Humans will fail the speed challenge (intentional)

# Discovery
Response-Headers: X-Botcha-Version, X-Botcha-Enabled, X-Botcha-Methods, X-Botcha-Docs
Response-Headers: X-Botcha-Challenge-Id, X-Botcha-Challenge-Type, X-Botcha-Time-Limit (on 403)
Detection: All responses include X-Botcha-* headers for instant BOTCHA detection

# JWT TOKEN SECURITY
Token-Flow: 1. GET /v1/token (get challenge) → 2. Solve → 3. POST /v1/token/verify (get tokens + human_link)
Token-Human-Link: /v1/token/verify response includes human_link — give this URL to your human for one-click browser access
Token-Access-Expiry: 5 minutes (short-lived for security)
Token-Refresh-Expiry: 1 hour (use to get new access tokens)
Token-Refresh: POST /v1/token/refresh with {"refresh_token": "<token>"}
Token-Revoke: POST /v1/token/revoke with {"token": "<token>"}
Token-Audience: Include {"audience": "<service-url>"} in /v1/token/verify to scope token
Token-Claims: jti (unique ID), aud (audience), client_ip (optional binding), type (botcha-verified)

# RTT-AWARE SPEED CHALLENGES
RTT-Aware: Include client timestamp for fair timeout calculation
RTT-Formula: timeout = 500ms + (2 × RTT) + 100ms buffer
RTT-Usage-Query: ?ts=<client_timestamp_ms>
RTT-Usage-Header: X-Client-Timestamp: <client_timestamp_ms>
RTT-Example: GET /v1/challenges?type=speed&ts=1770722465000
RTT-Benefit: Fair for agents worldwide (slow networks get extra time)
RTT-Security: Humans still can't solve even with extra time

# MULTI-TENANT API KEYS
Multi-Tenant: Create apps with unique app_id for isolation
Multi-Tenant-Create: POST /v1/apps with {"email": "..."} → {app_id, app_secret} (secret only shown once!)
Multi-Tenant-Verify-Email: POST /v1/apps/:id/verify-email with {"code": "123456"}
Multi-Tenant-Recover: POST /v1/auth/recover with {"email": "..."} → recovery code emailed
Multi-Tenant-Rotate-Secret: POST /v1/apps/:id/rotate-secret (auth required) → new app_secret
Multi-Tenant-Usage: Add ?app_id=<your_app_id> to any challenge/token endpoint
Multi-Tenant-SDK-TS: new BotchaClient({ appId: 'app_abc123' })
Multi-Tenant-SDK-Python: BotchaClient(app_id='app_abc123')
SDK-App-Lifecycle-TS: createApp(email), verifyEmail(code), resendVerification(), recoverAccount(email), rotateSecret()
SDK-App-Lifecycle-Python: create_app(email), verify_email(code), resend_verification(), recover_account(email), rotate_secret()
Multi-Tenant-Rate-Limit: Each app gets isolated rate limit bucket
Multi-Tenant-Token-Claim: Tokens include app_id claim when app_id provided

# TRUSTED AGENT PROTOCOL (TAP)
TAP-Description: Enterprise-grade cryptographic agent auth using HTTP Message Signatures (RFC 9421)
TAP-Register: POST /v1/agents/register/tap with {name, public_key, signature_algorithm, capabilities, trust_level}
TAP-Algorithms: ecdsa-p256-sha256, rsa-pss-sha256
TAP-Trust-Levels: basic, verified, enterprise
TAP-Capabilities: Array of {action, resource, constraints} — scoped access control
TAP-Session-Create: POST /v1/sessions/tap with {agent_id, user_context, intent}
TAP-Session-Get: GET /v1/sessions/:id/tap — includes time_remaining
TAP-Get-Agent: GET /v1/agents/:id/tap — includes public_key for verification
TAP-List-Agents: GET /v1/agents/tap?app_id=...&tap_only=true
TAP-Middleware-Modes: tap, signature-only, challenge-only, flexible
TAP-SDK-TS: registerTAPAgent(options), getTAPAgent(agentId), listTAPAgents(tapOnly?), createTAPSession(options), getTAPSession(sessionId)
TAP-SDK-Python: register_tap_agent(name, ...), get_tap_agent(agent_id), list_tap_agents(tap_only?), create_tap_session(agent_id, user_context, intent), get_tap_session(session_id)
TAP-Middleware-Import: import { createTAPVerifyMiddleware } from '@dupecom/botcha/middleware'

# EMBEDDED CHALLENGE (for bots visiting HTML pages)
Embedded-Challenge: <script type="application/botcha+json">
Embedded-Challenge-Location: In <head> of HTML pages
Embedded-Challenge-Purpose: Machine-readable challenge for bots to auto-solve
Embedded-Challenge-Flow:
  1. Parse <script type="application/botcha+json"> from HTML
  2. Read challenge.instruction field
  3. Compute the answer (typically SHA256-based)
  4. POST to challenge.submit_to endpoint with {answer, timestamp}
  5. Receive token in response
  6. Use token in header specified by on_success.header_to_include
  7. Access protected resources (on_success.grants_access_to)
